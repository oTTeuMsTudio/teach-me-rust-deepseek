
Structs so podatkovne strukture, ki omogočajo združevanje več povezanih vrednosti v eno samo entiteto. Vsaka vrednost v strukturi ima svoje ime in podatkovni tip. Strukture so podobne objektom v drugih jezikih, vendar nimajo metod (razen če jih eksplicitno dodamo).

### Definicija strukture

Za definicijo strukture uporabimo ključno besedo `struct`, sledi ime strukture in nato v zavitih oklepajih navedemo imena polj (fields) in njihove podatkovne tipe.

```rust
struct Oseba {
    ime: String,
    starost: u8,
    visina: f32,
}
```

V tem primeru smo definirali strukturo `Oseba`, ki ima tri polja:
- `ime` tipa `String` (niz znakov),
- `starost` tipa `u8` (8-bitno nepredznačeno celo število),
- `visina` tipa `f32` (32-bitno plavajočo vejico).

### Inicializacija strukture

Ko imamo strukturo definirano, jo lahko inicializiramo (ustvarimo instanco) tako, da podamo vrednosti za vsako polje.

```rust
let oseba1 = Oseba {
    ime: String::from("Janez"),
    starost: 30,
    visina: 1.75,
};
```

Tukaj smo ustvarili instanco strukture `Oseba` z imenom `oseba1`. Polju `ime` smo priredili vrednost `"Janez"`, polju `starost` vrednost `30` in polju `visina` vrednost `1.75`.

### Dostop do polj strukture

Do posameznih polj strukture lahko dostopamo s piko (`.`).

```rust
println!("Ime: {}", oseba1.ime);
println!("Starost: {}", oseba1.starost);
println!("Višina: {}", oseba1.visina);
```

Ta koda bo izpisala:
```
Ime: Janez
Starost: 30
Višina: 1.75
```

### Mutable strukture

Če želimo spremeniti vrednosti polj v strukturi, moramo instanco strukture narediti mutable (spremenljivo) s ključno besedo `mut`.

```rust
let mut oseba2 = Oseba {
    ime: String::from("Ana"),
    starost: 25,
    visina: 1.68,
};

oseba2.starost = 26;  // Spremenimo starost
```

### Skrajšana inicializacija

Če imamo spremenljivke z istimi imeni kot polja strukture, lahko uporabimo skrajšano inicializacijo.

```rust
let ime = String::from("Miha");
let starost = 28;
let visina = 1.80;

let oseba3 = Oseba {
    ime,
    starost,
    visina,
};
```

V tem primeru Rust samodejno uporabi spremenljivke `ime`, `starost` in `visina` za inicializacijo ustreznih polj v strukturi.

### Posodabljanje strukture z drugimi strukturami

Če želimo ustvariti novo strukturo, ki ima večino podatkov enakih kot obstoječa struktura, lahko uporabimo sintakso `..`.

```rust
let oseba4 = Oseba {
    ime: String::from("Luka"),
    ..oseba3
};
```

V tem primeru bo `oseba4` imela enako `starost` in `visina` kot `oseba3`, vendar drugačno `ime`.

### Tuple Structs

Obstajajo tudi tuple structs, ki so podobne običajnim strukturam, vendar nimajo imenovanih polj.

```rust
struct Barva(i32, i32, i32);

let rdeca = Barva(255, 0, 0);
```

Tu smo definirali tuple struct `Barva` s tremi polji tipa `i32`. Inicializirali smo ga z vrednostmi `(255, 0, 0)`.

### Unit-Like Structs

Unit-like structs so strukture brez polj. Uporabne so, ko želimo implementirati lastnosti (traits) ali markerje, vendar ne potrebujemo shranjevati podatkov.

```rust
struct Prazno;

let p = Prazno;
```

To je osnovno vse, kar potrebuješ za začetek dela s strukturami v Rustu. Če imaš kakršnakoli dodatna vprašanja, lahko vprašaš!

---

### Ownership v strukturah struct

Ko definiramo strukturo, lahko njena polja vsebujejo podatke, ki imajo različne lastniške odnose. Na primer, polje tipa `String` ima lastništvo nad svojimi podatki, medtem ko polje tipa `&str` (referenca na niz) ne.

#### Primer strukture z lastništvom

```rust
struct Oseba {
    ime: String,  // String ima lastništvo nad podatki
    starost: u8,
}
```

Ko ustvarimo instanco te strukture, ima `Oseba` lastništvo nad poljem `ime`, ki je tipa `String`.

```rust
let oseba1 = Oseba {
    ime: String::from("Janez"),
    starost: 30,
};
```

Ko `oseba1` izstopi iz obsega (npr. na koncu funkcije), se pomnilnik, ki ga je imel `ime`, samodejno osvobodi.

#### Prenos lastništva

Če želimo prenesti lastništvo strukture ali njenih polj, lahko to storimo z enostavno dodelitvijo.

```rust
let oseba2 = oseba1;  // Lastništvo `oseba1` se prenese na `oseba2`
```

Po tem prenosu `oseba1` ni več veljavna in je ne moremo več uporabljati, ker je lastništvo preneseno na `oseba2`.

```rust
// println!("{}", oseba1.ime);  // To bi povzročilo napako, ker `oseba1` ni več veljavna
println!("{}", oseba2.ime);  // To deluje, ker ima `oseba2` lastništvo
```

#### Reference brez lastništva

Če želimo uporabljati podatke brez prevzema lastništva, lahko uporabimo reference. Reference so označene z `&`.

```rust
struct OsebaRef<'a> {
    ime: &'a str,  // Referenca na niz, brez lastništva
    starost: u8,
}
```

Tu `'a` označuje življenjsko dobo (lifetime) reference. To pomeni, da mora referenca `ime` živeti vsaj toliko časa, kot struktura `OsebaRef`.

```rust
let ime = String::from("Ana");
let oseba3 = OsebaRef {
    ime: &ime,
    starost: 25,
};

println!("{}", oseba3.ime);  // Izpiše: Ana
```

V tem primeru `OsebaRef` ne prevzame lastništva nad `ime`, ampak le hrani referenco nanj. Zato moramo poskrbeti, da `ime` ostane veljaven, dokler ga uporablja `OsebaRef`.

### Kloniranje za ohranitev lastništva

Če želimo ohraniti lastništvo in še vedno uporabljati podatke, lahko uporabimo metodo `clone`.

```rust
let oseba4 = Oseba {
    ime: oseba2.ime.clone(),  // Kloniramo `ime`, da ohranimo lastništvo
    starost: oseba2.starost,
};

println!("{}", oseba2.ime);  // To še vedno deluje, ker smo klonirali `ime`
println!("{}", oseba4.ime);  // To tudi deluje
```

### Sklep

Lastništvo v Rustu je močan koncept, ki zagotavlja varnost pomnilnika. Pri strukturah moramo biti pozorni na to, katera polja imajo lastništvo in katera so le reference. Z uporabo referenc (`&`) lahko preprečimo nepotrebno kopiranje podatkov, vendar moramo paziti na življenjsko dobo teh referenc. Kloniranje (`clone`) je način, kako ohraniti lastništvo, vendar lahko prinese dodatne stroške.

