
Kaj je Sintaksa metode vklju캜no z definicijami, ve캜 parametri, asociiranimi funkcijami in ve캜 impl bloki?

### **Definiranje metod**

Metode so funkcije, ki so povezane z dolo캜eno vrsto podatkov (strukturo, enum, itd.). Definiramo jih znotraj `impl` bloka.

```rust
struct Tocka {
    x: i32,
    y: i32,
}

impl Tocka {
    // To je metoda, ki premakne to캜ko.
    fn premakni(&mut self, dx: i32, dy: i32) {
        self.x += dx;
        self.y += dy;
    }

    // To je metoda, ki vrne razdaljo do izhodi코캜a.
    fn razdalja_do_izhodisca(&self) -> f64 {
        ((self.x as f64).powi(2) + (self.y as f64).powi(2)).sqrt()
    }
}

fn main() {
    let mut tocka = Tocka { x: 5, y: 10 };
    tocka.premakni(2, -3);
    println!("Nova lokacija: x={}, y={}", tocka.x, tocka.y); // Izpis: Nova lokacija: x=7, y=7
    let razdalja = tocka.razdalja_do_izhodisca();
    println!("Razdalja do izhodi코캜a: {}", razdalja);
}
```

- `struct Tocka { ... }`: Definiramo strukturo `Tocka` z dvema poljema: `x` in `y`, oba tipa `i32` (cela 코tevila).
- `impl Tocka { ... }`: `impl` blok pove, da bomo definirali metode za tip `Tocka`.
- `fn premakni(&mut self, dx: i32, dy: i32) { ... }`: To je definicija metode `premakni`.
    - `&mut self`: `self` predstavlja instanco strukture `Tocka`. `&mut` pomeni, da lahko metodo uporabimo za spreminjanje instance (ker je `self` spremenljiv).
    - `dx: i32, dy: i32`: To sta parametra metode, oba tipa `i32`.
- `fn razdalja_do_izhodisca(&self) -> f64 { ... }`: To je definicija metode `razdalja_do_izhodisca`.
    - `&self`: Tudi tukaj `self` predstavlja instanco strukture `Tocka`, vendar `&` pomeni, da metode ne more spreminjati instance.
    - `-> f64`: To dolo캜a, da metoda vra캜a vrednost tipa `f64` (plavajo캜e 코tevilo).

### **Metode z ve캜 parametri**

Kot smo videli v primeru zgoraj, lahko metode sprejmejo poljubno 코tevilo parametrov, lo캜enih z vejicami.

### **Asociirane funkcije**

Asociirane funkcije so podobne metodam, vendar niso povezane z dolo캜eno instanco tipa. Kli캜emo jih neposredno na tipu, ne na instanci. Uporabljajo se pogosto za konstruktorje ali druge funkcije, ki so logi캜no povezane s tipom, vendar ne delujejo neposredno na instanci.

```rust
impl Tocka {
    // To je asociirana funkcija (konstruktor).
    fn nova(x: i32, y: i32) -> Tocka {
        Tocka { x, y }
    }
}

fn main() {
    let tocka = Tocka::nova(3, 4); // Klic asociirane funkcije
    // ...
}
```

- `fn nova(x: i32, y: i32) -> Tocka { ... }`: To je asociirana funkcija, ki ustvari novo instanco `Tocka`. Ne uporablja `self`. Kli캜emo jo z `Tocka::nova(3, 4)`.

### **Ve캜 `impl` blokov**

V Rustu je mogo캜e imeti ve캜 `impl` blokov za isti tip. To je koristno za organizacijo kode.

```rust
impl Tocka {
    fn izpisi(&self) {
        println!("x={}, y={}", self.x, self.y);
    }
}

impl Tocka {
    fn drugo_dejanje(&self) {
        // ...
    }
}
```

To je povsem veljavno in omogo캜a bolj코o organizacijo, 코e posebej, ko ima tip veliko metod.

Upam, da je to razumljivo. 캛e ima코 코e kak코no vpra코anje, kar vpra코aj!
# Sintaksa metod 2
Metode so posebna vrsta funkcij, ki so povezane z dolo캜enim tipom (struct, enum ali druga캜nim tipom). Spodaj je razlo쬴tev osnovnih konceptov, kot so definiranje metod, metode z ve캜 parametri, povezane funkcije in ve캜 `impl` blokov.

---

### 1. **Definiranje metod**
Metode se definirajo znotraj bloka `impl`, ki je povezan z dolo캜enim tipom. Uporabljamo besedo `self`, da se sklicujemo na primerek samega objekta.

#### Primer:
```rust
struct Oseba {
    ime: String,
    starost: u8,
}

impl Oseba {
    // Definicija metode
    fn prikazi(&self) {
        println!("Ime: {}, Starost: {}", self.ime, self.starost);
    }
}

fn main() {
    let oseba = Oseba {
        ime: String::from("Ana"),
        starost: 30,
    };
    oseba.prikazi(); // Izpis: Ime: Ana, Starost: 30
}
```

**Pojasnitev:**
- `&self` pomeni, da metoda prejme imenovanjo (`reference`) do trenutnega primmerka.
- 캛e 쬰lite spremeniti stanje objekta, uporabite `&mut self`.
- 캛e 쬰lite potro코iti objekt, uporabite `self`.

---

### 2. **Metode z ve캜 parametri**
Metode lahko sprejemajo ve캜 dodatnih parametrov, podobno kot obi캜ajne funkcije.

#### Primer:
```rust
impl Oseba {
    // Metoda s parametrom
    fn pozdravi(&self, kdo: &str) {
        println!("Pozdravljen, {}. Ja sem {}.", kdo, self.ime);
    }
}

fn main() {
    let oseba = Oseba {
        ime: String::from("Ana"),
        starost: 30,
    };
    oseba.pozdravi("Boris"); // Izpis: Pozdravljen, Boris. Ja sem Ana.
}
```

**Pojasnitev:**
- Parameter `kdo` je dodaten parameter metode.
- `self` ostaja prvi parameter, ki predstavlja primerek objekta.

---

### 3. **Povezane funkcije (associated functions)**
Povezane funkcije so funkcije, ki jih definirate znotraj `impl` bloka, vendar ne zahtevajo `self`. To pomeni, da jih lahko kli캜ete brez primereka objekta. Pogosto jih uporabljamo kot "konstruktorje" za stvarjanje novih primerkov.

#### Primer:
```rust
impl Oseba {
    // Povezana funkcija kot konstruktor
    fn nova(ime: String, starost: u8) -> Oseba {
        Oseba { ime, starost }
    }

    fn prikazi(&self) {
        println!("Ime: {}, Starost: {}", self.ime, self.starost);
    }
}

fn main() {
    let oseba = Oseba::nova(String::from("Ana"), 30);
    oseba.prikazi(); // Izpis: Ime: Ana, Starost: 30
}
```

**Pojasnitev:**
- `Oseba::nova` je povezana funkcija, ki jo kli캜emo na strukturi `Oseba`.
- Tak코ne funkcije so uporabne za inicializacijo objektov.

---

### 4. **Ve캜 `impl` blokov**
Rust dovoljuje, da imate ve캜 `impl` blokov za isti tip. To omogo캜a bolj코o organizacijo kode.

#### Primer:
```rust
struct Kalkulator;

impl Kalkulator {
    fn sestej(a: i32, b: i32) -> i32 {
        a + b
    }
}

impl Kalkulator {
    fn odstej(a: i32, b: i32) -> i32 {
        a - b
    }
}

fn main() {
    let vsota = Kalkulator::sestej(5, 3);
    let razlika = Kalkulator::odstej(10, 4);

    println!("Vsota: {}", vsota);   // Izpis: Vsota: 8
    println!("Razlika: {}", razlika); // Izpis: Razlika: 6
}
```

**Pojasnitev:**
- Dva `impl` bloka za `Kalkulator`.
- Vse funkcije so povezane funkcije, ker ne uporabljajo `self`.

---

### 5. **Generi캜ni impl bloki**
Impl bloki lahko definirate tudi za generi캜ne tipove.

#### Primer:
```rust
struct Vektor<T> {
    podatki: Vec<T>,
}

impl<T> Vektor<T> {
    fn nov() -> Self {
        Vektor { podatki: Vec::new() }
    }

    fn dodaj(&mut self, item: T) {
        self.podatki.push(item);
    }
}

fn main() {
    let mut vektor = Vektor::<i32>::nov();
    vektor.dodaj(10);
    vektor.dodaj(20);

    println!("Vektor ima {} elementov.", vektor.podatki.len());
}
```

**Pojasnitev:**
- `impl<T>` pomeni, da je ta `impl` blok generi캜en za poljubni tip `T`.
- `Self` je kratica za tip, za katerega je definiran `impl` blok (v tem primeru `Vektor<T>`).

---

### Zaklju캜ek
- **Metode** so funkcije, ki jih definirate znotraj `impl` bloka in uporabljajo `self` za dostop do primereka objekta.
- **Povezane funkcije** so funkcije, ki jih lahko kli캜ete brez primereka objekta.
- Lahko imate **ve캜 `impl` blokov** za en tip, kar pomaga pri organizaciji kode.
- **Generi캜ni impl bloki** omogo캜ajo delovanje z razli캜nimi tipi.

캛e imate 코e kake vpra코anje, mi je prosim sporo캜ite! 游땕
