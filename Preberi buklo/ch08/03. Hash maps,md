# Hash maps
In Rust, the most common way to store keys with associated values (i.e., a key-value map) is by using the `HashMap<K, V>` type from the standard library. A `HashMap` maps keys of type `K` to values of type `V`, similar to dictionaries in Python or objects in JavaScript.

---

## ğŸ§  What is a HashMap?

A `HashMap` allows you to:
- Insert key-value pairs.
- Access values by their key.
- Update or remove values based on keys.
- Check if a key exists.

---

## ğŸ”§ Using `HashMap` in Rust

### 1. **Importing HashMap**

First, you need to import it:

```rust
use std::collections::HashMap;
```

---

### 2. **Creating a New HashMap**

```rust
let mut scores = HashMap::new();
```

Now we can insert values.

---

### 3. **Inserting Values**

Use `.insert(key, value)` to add entries.

```rust
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

Make sure the types of your keys and values are consistent.

> âš ï¸ Note: The key type must implement the `Eq` and `Hash` traits. Many built-in types like `String`, `&str`, integers, booleans, etc., do this automatically.

---

### 4. **Accessing Values**

Use `.get(&key)` to retrieve a value:

```rust
let blue_score = scores.get("Blue");
match blue_score {
    Some(score) => println!("Blue team scored {} points", score),
    None => println!("Blue team not found"),
}
```

Or use short-hand:

```rust
println!("{:?}", scores.get("Blue")); // Outputs: Some(10)
```

---

### 5. **Updating Values**

There are several common patterns:

#### ğŸ” Overwriting a Value

```rust
scores.insert("Blue".to_string(), 25); // Now Blue has 25
```

#### â• Adding Only If Absent

```rust
scores.entry("Green".to_string()).or_insert(30);
```

This inserts only if `"Green"` doesn't exist yet.

#### ğŸ”„ Modify Based on Current Value

```rust
let count = scores.entry("Blue".to_string()).or_insert(0);
*count += 1; // Increment Blue's score
```

---

### 6. **Iterating Over HashMap**

You can iterate over key-value pairs:

```rust
for (key, value) in &scores {
    println!("{}: {}", key, value);
}
```

---

### âœ… Example: Full Program

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    scores.insert("Blue".to_string(), 10);
    scores.insert("Yellow".to_string(), 50);

    // Access value
    if let Some(score) = scores.get("Blue") {
        println!("Blue score: {}", score);
    }

    // Update entry
    *scores.entry("Blue".to_string()).or_insert(0) += 1;

    // Print all
    for (team, &score) in &scores {
        println!("{}: {}", team, score);
    }
}
```

**Output:**
```
Blue score: 10
Blue: 11
Yellow: 50
```

---

## ğŸ“Œ Notes

- Keys must be of a type that implements `Eq` and `Hash`.
- Be aware of ownership rules when inserting or accessing values:
  - `.insert()` takes ownership of both key and value unless you're using references with proper lifetimes.
- Use `.clone()` if needed, but avoid unnecessary cloning for performance.

---

## ğŸ› ï¸ Advanced Usage

- You can use `hashbrown::HashMap` (faster hashmap implementation) via the `hashbrown` crate.
- For ordered maps (e.g., keep insertion order), use the `indexmap` crate.

---

# Would you like an example using integers as keys? Or something more complex like storing vectors in a hashmap?

Let's go a bit deeper and take a look at some **more complex examples** of using `HashMap` in Rust, including:

1. Storing different types (like `i32`, `&str`, `Vec<T>`)
2. Using `HashMap` with `match` and `entry`
3. Grouping data by key (e.g., summing values or collecting lists)

---

## ğŸ”¢ Example 1: HashMap with Integer Keys

```rust
use std::collections::HashMap;

fn main() {
    let mut ages = HashMap::new();

    // Insert integer keys and values
    ages.insert(101, "Alice");
    ages.insert(102, "Bob");

    // Access value
    if let Some(name) = ages.get(&101) {
        println!("ID 101 is {}", name);
    }

    // Iterate
    for (&id, &name) in &ages {
        println!("ID {}: {}", id, name);
    }
}
```

### âœ… Output:
```
ID 101 is Alice
ID 101: Alice
ID 102: Bob
```

---

## ğŸ“¦ Example 2: HashMap with `Vec<T>` as Values

Letâ€™s say we want to group students into teams:

```rust
use std::collections::HashMap;

fn main() {
    let students = vec![
        ("Alice", "Math"),
        ("Bob", "Science"),
        ("Charlie", "Math"),
        ("David", "History"),
        ("Eve", "Science"),
    ];

    let mut groups: HashMap<&str, Vec<&str>> = HashMap::new();

    for (student, group) in students {
        groups.entry(group).or_insert_with(Vec::new).push(student);
    }

    for (group, members) in &groups {
        println!("{}: {:?}", group, members);
    }
}
```

### âœ… Output:
```
Math: ["Alice", "Charlie"]
Science: ["Bob", "Eve"]
History: ["David"]
```

---

## ğŸ§® Example 3: Summing Values by Key

Suppose you're counting fruits collected over multiple days.

```rust
use std::collections::HashMap;

fn main() {
    let fruits = vec![
        ("apple", 3),
        ("banana", 2),
        ("apple", 2),
        ("orange", 5),
        ("banana", 4),
    ];

    let mut basket = HashMap::new();

    for (fruit, count) in fruits {
        let total = basket.entry(fruit).or_insert(0);
        *total += count;
    }

    for (fruit, total) in &basket {
        println!("Total {}s: {}", fruit, total);
    }
}
```

### âœ… Output:
```
Total apples: 5
Total bananas: 6
Total oranges: 5
```

---

## ğŸ“š Bonus: Nested HashMap (Map inside Map)

You can have nested structures like `HashMap<String, HashMap<String, i32>>`.

This is useful for hierarchical grouping, like team scores per round:

```rust
use std::collections::HashMap;

fn main() {
    let results = vec![
        ("Blue", "Round1", 10),
        ("Blue", "Round2", 15),
        ("Red", "Round1", 8),
        ("Red", "Round2", 12),
    ];

    let mut team_scores: HashMap<_, HashMap<_, _>> = HashMap::new();

    for (team, round, score) in results {
        team_scores
            .entry(team)
            .or_insert_with(HashMap::new)
            .insert(round, score);
    }

    for (team, rounds) in &team_scores {
        println!("Team {}", team);
        for (round, score) in rounds {
            println!("  {}: {}", round, score);
        }
    }
}
```

### âœ… Output:
```
Team Blue
  Round1: 10
  Round2: 15
Team Red
  Round1: 8
  Round2: 12
```

---

## ğŸ’¡ Recap Tips

- Use `.entry().or_insert()` to smartly insert or update.
- You can store any type in the values â€” even `Vec<T>`, `HashMap<K,V>`, or custom structs.
- Be mindful of ownership when inserting references or strings.
- For performance-critical contexts, consider using crates like `hashbrown` or `ahash`.

---

Would you like to see how to use a custom struct as a key in a `HashMap`? Or maybe serialize/deserialize a hashmap using `serde`?
